# Ø¯Ø³ØªÙˆØ±Ø§Ù„Ø¹Ù…Ù„ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ù¾Ø§ÛŒØ¯Ø§Ø± Ø±Ø¨Ø§Øª ØªÙ„Ú¯Ø±Ø§Ù… Ù¾ÛŒØ´Ø±ÙØªÙ‡

Ø§ÛŒÙ† ÙØ§ÛŒÙ„ Ø´Ø§Ù…Ù„ Ú©Ø¯ Ù†Ù‡Ø§ÛŒÛŒ Ø±Ø¨Ø§Øª ØªÙ„Ú¯Ø±Ø§Ù… Ø´Ù…Ø§ Ùˆ Ø¯Ø³ØªÙˆØ±Ø§Ù„Ø¹Ù…Ù„â€ŒÙ‡Ø§ÛŒ Ù„Ø§Ø²Ù… Ø¨Ø±Ø§ÛŒ Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ø¢Ù† Ø¨Ù‡ ØµÙˆØ±Øª Ù¾Ø§ÛŒØ¯Ø§Ø± Ø¨Ø± Ø±ÙˆÛŒ ÛŒÚ© Ø³Ø±ÙˆØ± Ø¯Ø§Ø¦Ù…ÛŒ Ø§Ø³Øª.

## Û±. Ù¾ÛŒØ´â€ŒÙ†ÛŒØ§Ø²Ù‡Ø§

Ø¨Ø±Ø§ÛŒ Ø§Ø¬Ø±Ø§ÛŒ Ù¾Ø§ÛŒØ¯Ø§Ø± Ø±Ø¨Ø§ØªØŒ Ø¨Ù‡ Ù…ÙˆØ§Ø±Ø¯ Ø²ÛŒØ± Ù†ÛŒØ§Ø² Ø¯Ø§Ø±ÛŒØ¯:

1.  **ÛŒÚ© Ø³Ø±ÙˆØ± Ù…Ø¬Ø§Ø²ÛŒ (VPS) ÛŒØ§ Ú©Ø§Ù…Ù¾ÛŒÙˆØªØ± Ø´Ø®ØµÛŒ Ù‡Ù…ÛŒØ´Ù‡ Ø±ÙˆØ´Ù†:** Ø¨Ø±Ø§ÛŒ Ø§Ø¬Ø±Ø§ÛŒ Ø¯Ø§Ø¦Ù…ÛŒ Ú©Ø¯.
2.  **Ù†ØµØ¨ Python 3.10+**
3.  **ØªÙˆÚ©Ù† Ø±Ø¨Ø§Øª ØªÙ„Ú¯Ø±Ø§Ù…** (Ø§Ø² BotFather)
4.  **Ú©Ù„ÛŒØ¯ API Ø§ÙˆÙ¾Ù†â€ŒØ§ÛŒâ€ŒØ¢ÛŒ (OpenAI API Key)**: Ø¨Ø±Ø§ÛŒ Ù‚Ø§Ø¨Ù„ÛŒØªâ€ŒÙ‡Ø§ÛŒ ØªÙˆÙ„ÛŒØ¯ ØªØµÙˆÛŒØ±ØŒ ØµØ¯Ø§ Ùˆ ØªØ¨Ø¯ÛŒÙ„ ÙˆÛŒØ³ Ø¨Ù‡ Ù…ØªÙ†.

## Û². Ø±Ø§Ù‡â€ŒØ§Ù†Ø¯Ø§Ø²ÛŒ Ù…Ø­ÛŒØ·

Ø¯Ø± Ø³Ø±ÙˆØ± Ø®ÙˆØ¯ØŒ Ù…Ø±Ø§Ø­Ù„ Ø²ÛŒØ± Ø±Ø§ Ø¯Ù†Ø¨Ø§Ù„ Ú©Ù†ÛŒØ¯:

### Ø§Ù„Ù. Ù†ØµØ¨ Ù¾ÛŒØ´â€ŒÙ†ÛŒØ§Ø²Ù‡Ø§ÛŒ Ù¾Ø§ÛŒØªÙˆÙ†

```bash
# Ù†ØµØ¨ Ù…Ø­ÛŒØ· Ù…Ø¬Ø§Ø²ÛŒ
python3 -m venv telegram_bot_venv

# ÙØ¹Ø§Ù„â€ŒØ³Ø§Ø²ÛŒ Ù…Ø­ÛŒØ· Ù…Ø¬Ø§Ø²ÛŒ
source telegram_bot_venv/bin/activate

# Ù†ØµØ¨ Ú©ØªØ§Ø¨Ø®Ø§Ù†Ù‡â€ŒÙ‡Ø§ÛŒ Ù…ÙˆØ±Ø¯ Ù†ÛŒØ§Ø²
pip install python-telegram-bot openai requests
```

### Ø¨. Ø°Ø®ÛŒØ±Ù‡ Ú©Ø¯ Ø±Ø¨Ø§Øª

ÙØ§ÛŒÙ„ `bot.py` Ø±Ø§ Ø¨Ø§ Ù…Ø­ØªÙˆØ§ÛŒ Ø²ÛŒØ± Ø¯Ø± Ø³Ø±ÙˆØ± Ø®ÙˆØ¯ Ø°Ø®ÛŒØ±Ù‡ Ú©Ù†ÛŒØ¯.

**ØªÙˆØ¬Ù‡:** Ø¯Ø± Ø®Ø· Û±Û² Ú©Ø¯ØŒ **ØªÙˆÚ©Ù† Ø±Ø¨Ø§Øª** Ø´Ù…Ø§ Ø¨Ù‡ ØµÙˆØ±Øª Ø²ÛŒØ± ØªÙ†Ø¸ÛŒÙ… Ø´Ø¯Ù‡ Ø§Ø³Øª:
`BOT_TOKEN = "7706907691:AAGhZZBsfDWLi8HROXAGROA7nILUBOpp5yY"`

Ø§Ú¯Ø± ØªÙˆÚ©Ù† Ø±Ø¨Ø§Øª Ø´Ù…Ø§ ØªØºÛŒÛŒØ± Ú©Ø±Ø¯Ù‡ Ø§Ø³ØªØŒ Ø­ØªÙ…Ø§Ù‹ Ø¢Ù† Ø±Ø§ Ø¯Ø± Ø§ÛŒÙ† Ø®Ø· Ø¨Ù‡â€ŒØ±ÙˆØ²Ø±Ø³Ø§Ù†ÛŒ Ú©Ù†ÛŒØ¯.

### Ø¬. ØªÙ†Ø¸ÛŒÙ… Ú©Ù„ÛŒØ¯ API Ø§ÙˆÙ¾Ù†â€ŒØ§ÛŒâ€ŒØ¢ÛŒ

Ø¨Ø±Ø§ÛŒ Ø§ÛŒÙ†Ú©Ù‡ Ø±Ø¨Ø§Øª Ø¨ØªÙˆØ§Ù†Ø¯ Ø§Ø² Ø³Ø±ÙˆÛŒØ³â€ŒÙ‡Ø§ÛŒ OpenAI Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†Ø¯ØŒ Ø¨Ø§ÛŒØ¯ Ú©Ù„ÛŒØ¯ API Ø®ÙˆØ¯ Ø±Ø§ Ø¨Ù‡ Ø¹Ù†ÙˆØ§Ù† ÛŒÚ© Ù…ØªØºÛŒØ± Ù…Ø­ÛŒØ·ÛŒ ØªÙ†Ø¸ÛŒÙ… Ú©Ù†ÛŒØ¯.

```bash
export OPENAI_API_KEY="YOUR_OPENAI_API_KEY_HERE"
```
**ØªÙˆØ¬Ù‡:** Ø¨Ù‡ Ø¬Ø§ÛŒ `YOUR_OPENAI_API_KEY_HERE`ØŒ Ú©Ù„ÛŒØ¯ ÙˆØ§Ù‚Ø¹ÛŒ Ø®ÙˆØ¯ Ø±Ø§ Ù‚Ø±Ø§Ø± Ø¯Ù‡ÛŒØ¯.

## Û³. Ø§Ø¬Ø±Ø§ÛŒ Ø±Ø¨Ø§Øª

Ø¨Ø±Ø§ÛŒ Ø§Ø¬Ø±Ø§ÛŒ Ø±Ø¨Ø§Øª Ø¨Ù‡ ØµÙˆØ±Øª Ù¾Ø§ÛŒØ¯Ø§Ø± Ùˆ Ø¯Ø± Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡ (Ø­ØªÛŒ Ù¾Ø³ Ø§Ø² Ø¨Ø³ØªÙ† ØªØ±Ù…ÛŒÙ†Ø§Ù„)ØŒ Ø§Ø² Ø§Ø¨Ø²Ø§Ø±Ù‡Ø§ÛŒÛŒ Ù…Ø§Ù†Ù†Ø¯ `screen` ÛŒØ§ `tmux` ÛŒØ§ `nohup` Ø§Ø³ØªÙØ§Ø¯Ù‡ Ú©Ù†ÛŒØ¯. Ø³Ø§Ø¯Ù‡â€ŒØªØ±ÛŒÙ† Ø±ÙˆØ´ Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² `nohup` Ø§Ø³Øª:

```bash
# Ø§Ø¬Ø±Ø§ÛŒ Ø±Ø¨Ø§Øª Ø¯Ø± Ù¾Ø³â€ŒØ²Ù…ÛŒÙ†Ù‡
nohup python bot.py &

# Ø¨Ø±Ø§ÛŒ Ù…Ø´Ø§Ù‡Ø¯Ù‡ Ù„Ø§Ú¯â€ŒÙ‡Ø§ (Ø§Ø®ØªÛŒØ§Ø±ÛŒ)
tail -f nohup.out
```

## Û´. Ú©Ø¯ Ù†Ù‡Ø§ÛŒÛŒ Ø±Ø¨Ø§Øª (`bot.py`)

```python
import logging
import os
from telegram import Update
from telegram.ext import Application, CommandHandler, MessageHandler, filters, ContextTypes
from openai import OpenAI
import requests
import io
from datetime import datetime, timedelta

# --- Configuration ---
# ØªÙˆÚ©Ù† Ø±Ø¨Ø§Øª Ø®ÙˆØ¯ Ø±Ø§ Ø§ÛŒÙ†Ø¬Ø§ Ù‚Ø±Ø§Ø± Ø¯Ù‡ÛŒØ¯
BOT_TOKEN = "7706907691:AAGhZZBsfDWLi8HROXAGROA7nILUBOpp5yY"
# Ø§ÛŒÙ† Ù…ØªØºÛŒØ±Ù‡Ø§ Ø¨Ø±Ø§ÛŒ Polling ØºÛŒØ±Ø¶Ø±ÙˆØ±ÛŒ Ù‡Ø³ØªÙ†Ø¯ØŒ Ø§Ù…Ø§ Ø¯Ø± Ú©Ø¯ Ø¨Ø§Ù‚ÛŒ Ù…ÛŒâ€ŒÙ…Ø§Ù†Ù†Ø¯
WEBHOOK_URL = "https://8080-ijt1llq8z753utodvdpi1-324cad81.manusvm.computer"
PORT = 8080

# --- Logging ---
logging.basicConfig(
    format="%(asctime)s - %(name)s - %(levelname)s - %(message)s", level=logging.INFO
)
logger = logging.getLogger(__name__)

# --- OpenAI Client ---
try:
    # Ø§Ø³ØªÙØ§Ø¯Ù‡ Ø§Ø² Ù…Ø¯Ù„ Ø¨Ø§ Ú©ÛŒÙÛŒØª Ø¨Ø§Ù„Ø§ Ø¨Ø±Ø§ÛŒ ØµØ¯Ø§ÛŒ Ø§Ù†Ø³Ø§Ù†â€ŒÙ†Ù…Ø§
    TTS_MODEL = "tts-1-hd"
    # Ú©Ù„ÛŒØ¯ API Ø¨Ù‡ ØµÙˆØ±Øª Ø®ÙˆØ¯Ú©Ø§Ø± Ø§Ø² Ù…ØªØºÛŒØ± Ù…Ø­ÛŒØ·ÛŒ OPENAI_API_KEY Ø®ÙˆØ§Ù†Ø¯Ù‡ Ù…ÛŒâ€ŒØ´ÙˆØ¯
    client = OpenAI()
    openai_available = True
except Exception as e:
    logger.error(f"Failed to initialize OpenAI client: {e}")
    client = None
    openai_available = False

# --- Search Function (using a public API) ---
def perform_search(query: str):
    url = f"https://api.duckduckgo.com/?q={query}&format=json&pretty=1"
    try:
        response = requests.get(url)
        response.raise_for_status()
        data = response.json()
        if data.get("AbstractText"):
            return data["AbstractText"]
        elif data.get("RelatedTopics") and data["RelatedTopics"][0].get("Text"):
            return data["RelatedTopics"][0]["Text"]
        else:
            return "Ù…ØªØ§Ø³ÙØ§Ù†Ù‡ Ù†ØªÛŒØ¬Ù‡â€ŒØ§ÛŒ ÛŒØ§ÙØª Ù†Ø´Ø¯."
    except Exception as e:
        logger.error(f"Search failed: {e}")
        return "Ø¯Ø± Ø­Ø§Ù„ Ø­Ø§Ø¶Ø± Ø§Ù…Ú©Ø§Ù† Ø¬Ø³ØªØ¬Ùˆ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯."

# --- Earthquake Function ---
def get_earthquake_report():
    # USGS API for all earthquakes M2.5+ in the last 24 hours (focused on Iran region)
    start_time = (datetime.now() - timedelta(hours=24)).isoformat()
    end_time = datetime.now().isoformat()
    
    # Ù…Ø­Ø¯ÙˆØ¯Ù‡ Ø¬ØºØ±Ø§ÙÛŒØ§ÛŒÛŒ ØªÙ‚Ø±ÛŒØ¨ÛŒ Ø§ÛŒØ±Ø§Ù† Ùˆ Ø§Ø·Ø±Ø§Ù Ø¢Ù†
    url = (
        f"https://earthquake.usgs.gov/fdsnws/event/1/query?"
        f"format=geojson&starttime={start_time}&endtime={end_time}&minmagnitude=2.5"
        f"&maxlatitude=45&minlatitude=20&maxlongitude=70&minlongitude=35"
        f"&orderby=time"
    )
    
    try:
        response = requests.get(url, timeout=10)
        response.raise_for_status()
        data = response.json()
        
        features = data.get("features", [])
        if not features:
            return "Ø¯Ø± Û²Û´ Ø³Ø§Ø¹Øª Ú¯Ø°Ø´ØªÙ‡ØŒ Ø²Ù„Ø²Ù„Ù‡â€ŒØ§ÛŒ Ø¨Ø§ Ø¨Ø²Ø±Ú¯ÛŒ Û².Ûµ Ø±ÛŒØ´ØªØ± ÛŒØ§ Ø¨ÛŒØ´ØªØ± Ø¯Ø± Ù…Ù†Ø·Ù‚Ù‡ Ø§ÛŒØ±Ø§Ù† Ùˆ Ø§Ø·Ø±Ø§Ù Ø¢Ù† Ø«Ø¨Øª Ù†Ø´Ø¯Ù‡ Ø§Ø³Øª."
        
        report = "Ú¯Ø²Ø§Ø±Ø´ Ø²Ù„Ø²Ù„Ù‡â€ŒÙ‡Ø§ÛŒ Û²Û´ Ø³Ø§Ø¹Øª Ú¯Ø°Ø´ØªÙ‡ (Ø¨Ø²Ø±Ú¯ÛŒ Û².Ûµ Ø±ÛŒØ´ØªØ± ÛŒØ§ Ø¨ÛŒØ´ØªØ±):\n\n"
        for feature in features[:5]: # Ù…Ø­Ø¯ÙˆØ¯ Ø¨Ù‡ Ûµ Ù…ÙˆØ±Ø¯ Ø¢Ø®Ø±
            props = feature["properties"]
            mag = props["mag"]
            place = props["place"]
            time_ms = props["time"]
            
            # ØªØ¨Ø¯ÛŒÙ„ Ø²Ù…Ø§Ù† Ù…ÛŒÙ„ÛŒâ€ŒØ«Ø§Ù†ÛŒÙ‡ Ø¨Ù‡ Ø²Ù…Ø§Ù† Ù‚Ø§Ø¨Ù„ Ø®ÙˆØ§Ù†Ø¯Ù† (UTC)
            time_utc = datetime.fromtimestamp(time_ms / 1000).strftime('%Y-%m-%d %H:%M:%S UTC')
            
            report += f"ğŸ”¹ **Ø¨Ø²Ø±Ú¯ÛŒ:** {mag} Ø±ÛŒØ´ØªØ±\n"
            report += f"ğŸ“ **Ù…Ú©Ø§Ù†:** {place}\n"
            report += f"â± **Ø²Ù…Ø§Ù†:** {time_utc}\n"
            report += "----------------------------------\n"
            
        report += "\nÙ…Ù†Ø¨Ø¹: USGS"
        return report
        
    except requests.exceptions.RequestException as e:
        logger.error(f"Earthquake API error: {e}")
        return "Ù…ØªØ£Ø³ÙØ§Ù†Ù‡ Ø¯Ø± Ø­Ø§Ù„ Ø­Ø§Ø¶Ø± Ø§Ù…Ú©Ø§Ù† Ø¯Ø±ÛŒØ§ÙØª Ú¯Ø²Ø§Ø±Ø´ Ø²Ù„Ø²Ù„Ù‡ ÙˆØ¬ÙˆØ¯ Ù†Ø¯Ø§Ø±Ø¯."

# --- Bot Handlers ---
async def start(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Sends a welcome message and instructions."""
    instructions = (
        "Ø³Ù„Ø§Ù…! Ù…Ù† Ø±Ø¨Ø§Øª Ù¾ÛŒØ´Ø±ÙØªÙ‡ Ø´Ù…Ø§ Ù‡Ø³ØªÙ….\n\n"
        "Ø¯Ø³ØªÙˆØ±Ø§Øª Ù…ÙˆØ¬ÙˆØ¯:\n"
        "/generate <prompt> - ØªÙˆÙ„ÛŒØ¯ ØªØµÙˆÛŒØ±\n"
        "/speak <text> - ØªØ¨Ø¯ÛŒÙ„ Ù…ØªÙ† Ø¨Ù‡ ØµØ¯Ø§ÛŒ Ø§Ù†Ø³Ø§Ù†â€ŒÙ†Ù…Ø§\n"
        "/search <query> - Ø¬Ø³ØªØ¬ÙˆÛŒ Ø§Ø·Ù„Ø§Ø¹Ø§Øª\n"
        "/earthquake - Ø¯Ø±ÛŒØ§ÙØª Ø¢Ø®Ø±ÛŒÙ† Ú¯Ø²Ø§Ø±Ø´ Ø²Ù„Ø²Ù„Ù‡ (Û²Û´ Ø³Ø§Ø¹Øª Ú¯Ø°Ø´ØªÙ‡)\n\n"
        "Ù‡Ù…Ú†Ù†ÛŒÙ† Ù…ÛŒâ€ŒØªÙˆØ§Ù†ÛŒØ¯ Ø¨Ø±Ø§ÛŒ Ù…Ù† **Ù¾ÛŒØ§Ù… ØµÙˆØªÛŒ (ÙˆÛŒØ³)** Ø¨ÙØ±Ø³ØªÛŒØ¯ ØªØ§ Ø¢Ù† Ø±Ø§ Ø¨Ù‡ Ù…ØªÙ† ØªØ¨Ø¯ÛŒÙ„ Ú©Ù†Ù…."
    )
    await update.message.reply_text(instructions)

async def generate_image(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Generates an image based on user prompt."""
    if not openai_available:
        await update.message.reply_text("Ø³Ø±ÙˆÛŒØ³ ØªÙˆÙ„ÛŒØ¯ ØªØµÙˆÛŒØ± Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª.")
        return

    prompt = " ".join(context.args)
    if not prompt:
        await update.message.reply_text("Ù„Ø·ÙØ§ ØªÙˆØ¶ÛŒØ­Ø§Øª ØªØµÙˆÛŒØ± Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯. Ù…Ø«Ø§Ù„: /generate a robot artist")
        return

    await update.message.reply_text(f"Ø¯Ø± Ø­Ø§Ù„ ØªÙˆÙ„ÛŒØ¯ ØªØµÙˆÛŒØ± Ø¨Ø±Ø§ÛŒ: {prompt}...")
    try:
        response = client.images.generate(model="dall-e-2", prompt=prompt, n=1, size="512x512")
        image_url = response.data[0].url
        await update.message.reply_photo(photo=image_url, caption=f"ØªØµÙˆÛŒØ± Ø´Ù…Ø§ Ø¨Ø±Ø§ÛŒ: {prompt}")
    except Exception as e:
        logger.error(f"Image generation error: {e}")
        await update.message.reply_text(f"Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ ØªØµÙˆÛŒØ±: {e}")

async def text_to_speech(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Converts text to speech using a high-quality model."""
    if not openai_available:
        await update.message.reply_text("Ø³Ø±ÙˆÛŒØ³ ØªÙˆÙ„ÛŒØ¯ ØµØ¯Ø§ Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª.")
        return

    text = " ".join(context.args)
    if not text:
        await update.message.reply_text("Ù„Ø·ÙØ§ Ù…ØªÙ† Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯. Ù…Ø«Ø§Ù„: /speak Ø³Ù„Ø§Ù… Ø¯Ù†ÛŒØ§")
        return

    await update.message.reply_text(f"Ø¯Ø± Ø­Ø§Ù„ ØªØ¨Ø¯ÛŒÙ„ Ù…ØªÙ† Ø¨Ù‡ ØµØ¯Ø§ÛŒ Ø§Ù†Ø³Ø§Ù†â€ŒÙ†Ù…Ø§: {text}...")
    try:
        response = client.audio.speech.create(model=TTS_MODEL, voice="onyx", input=text)
        
        audio_file = io.BytesIO()
        for chunk in response.iter_bytes(chunk_size=4096):
            audio_file.write(chunk)
        audio_file.seek(0)

        await update.message.reply_audio(audio=audio_file, title="ØµØ¯Ø§ÛŒ ØªÙˆÙ„ÛŒØ¯ Ø´Ø¯Ù‡ Ø§Ù†Ø³Ø§Ù†â€ŒÙ†Ù…Ø§")
    except Exception as e:
        logger.error(f"Speech generation error: {e}")
        await update.message.reply_text(f"Ø®Ø·Ø§ Ø¯Ø± ØªÙˆÙ„ÛŒØ¯ ØµØ¯Ø§: {e}")

async def voice_to_text(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Converts user's voice message to text."""
    if not openai_available:
        await update.message.reply_text("Ø³Ø±ÙˆÛŒØ³ ØªØ¨Ø¯ÛŒÙ„ ÙˆÛŒØ³ Ø¨Ù‡ Ù…ØªÙ† Ø¯Ø± Ø¯Ø³ØªØ±Ø³ Ù†ÛŒØ³Øª.")
        return

    await update.message.reply_text("Ø¯Ø± Ø­Ø§Ù„ ØªØ¨Ø¯ÛŒÙ„ Ù¾ÛŒØ§Ù… ØµÙˆØªÛŒ Ø´Ù…Ø§ Ø¨Ù‡ Ù…ØªÙ†...")
    try:
        voice_file = await update.message.voice.get_file()
        voice_bytes = io.BytesIO()
        await voice_file.download_to_memory(voice_bytes)
        voice_bytes.name = "voice.ogg"

        transcript = client.audio.transcriptions.create(
            model="whisper-1", 
            file=voice_bytes
        )
        
        await update.message.reply_text(f"**Ù…ØªÙ† Ù¾ÛŒØ§Ù… ØµÙˆØªÛŒ Ø´Ù…Ø§:**\n\n{transcript.text}")

    except Exception as e:
        logger.error(f"Voice to text error: {e}")
        await update.message.reply_text(f"Ø®Ø·Ø§ Ø¯Ø± ØªØ¨Ø¯ÛŒÙ„ ÙˆÛŒØ³ Ø¨Ù‡ Ù…ØªÙ†: {e}")

async def search_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Performs a web search."""
    query = " ".join(context.args)
    if not query:
        await update.message.reply_text("Ù„Ø·ÙØ§ Ø¹Ø¨Ø§Ø±Øª Ù…ÙˆØ±Ø¯ Ù†Ø¸Ø± Ø¨Ø±Ø§ÛŒ Ø¬Ø³ØªØ¬Ùˆ Ø±Ø§ ÙˆØ§Ø±Ø¯ Ú©Ù†ÛŒØ¯. Ù…Ø«Ø§Ù„: /search Ù‚ÛŒÙ…Øª Ø¨ÛŒØªâ€ŒÚ©ÙˆÛŒÙ†")
        return

    await update.message.reply_text(f"Ø¯Ø± Ø­Ø§Ù„ Ø¬Ø³ØªØ¬Ùˆ Ø¨Ø±Ø§ÛŒ: {query}...")
    result = perform_search(query)
    await update.message.reply_text(result)

async def earthquake_command(update: Update, context: ContextTypes.DEFAULT_TYPE) -> None:
    """Provides the latest earthquake report."""
    await update.message.reply_text("Ø¯Ø± Ø­Ø§Ù„ Ø¯Ø±ÛŒØ§ÙØª Ø¢Ø®Ø±ÛŒÙ† Ú¯Ø²Ø§Ø±Ø´ Ø²Ù„Ø²Ù„Ù‡...")
    report = get_earthquake_report()
    await update.message.reply_text(report, parse_mode='Markdown')

async def unknown(update: Update, context: ContextTypes.DEFAULT_TYPE):
    await context.bot.send_message(chat_id=update.effective_chat.id, text="Ù…ØªØ§Ø³ÙØ§Ù†Ù‡ Ø§ÛŒÙ† Ø¯Ø³ØªÙˆØ± Ø±Ø§ Ù…ØªÙˆØ¬Ù‡ Ù†Ù…ÛŒâ€ŒØ´ÙˆÙ…. Ø¨Ø±Ø§ÛŒ Ø±Ø§Ù‡Ù†Ù…Ø§ÛŒÛŒ /start Ø±Ø§ Ø¨Ø²Ù†ÛŒØ¯.")

# --- Main Function ---
def main() -> None:
    """Starts the bot with Polling."""
    application = Application.builder().token(BOT_TOKEN).build()

    # Add handlers
    application.add_handler(CommandHandler("start", start))
    application.add_handler(CommandHandler("generate", generate_image))
    application.add_handler(CommandHandler("speak", text_to_speech))
    application.add_handler(CommandHandler("search", search_command))
    application.add_handler(CommandHandler("earthquake", earthquake_command))
    application.add_handler(MessageHandler(filters.VOICE & ~filters.COMMAND, voice_to_text))
    application.add_handler(MessageHandler(filters.COMMAND, unknown))

    # Start Polling
    logger.info("Bot is running with polling.")
    application.run_polling()

if __name__ == "__main__":
    main()
```
